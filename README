[rules : for this readme ]
[0] .  importent
[*] .  basic stuff (of course it  importent)
[-?-] ... [-?-] : this can be the valubale notes number to refer to exemeple : [-0-] note1 or even nested notes like this -> [-0-][-1-] -> this refer to note the subnote [-1-] of the note [-0-]

[rules: end]
Notes : all this notes ae base one (RFC 2616 )
    - every sinle line in the request will be ended bye CR+LF or we
        can just call it CRLF (10+13, IN ASCII CODE) except for the body.
    - HTTP/1.1 header field values can be folded onto multiple lines if the
        continuation line begins with a space or horizontal tab. All linear
        white space, including folding, has the same semantics as SP. A
        recipient MAY replace any linear white space with a single SP before
        interpreting the field value or forwarding the message downstream.
        LWS = [CRLF] 1*( SP | HT )
    - Many HTTP/1.1 header field values consist of words separated by LWS
        or special characters. These special characters MUST be in a quoted
        string to be used within a parameter value (as defined in section
        3.6).
        [0] . token = 1*<any CHAR except CTLs or separators>
        [0] . separators = "(" | ")" | "<" | ">" | "@"
        | "," | ";" | ":" | "\" | <">
        | "/" | "[" | "]" | "?" | "="
        | "{" | "}" | SP | HT
    "literal"
        Quotation marks surround literal text. Unless stated otherwise,
        the text is case-insensitive.
    *rule
        The character "*" preceding an element indicates repetition. The
        full form is "<n>*<m>element" indicating at least <n> and at most
        <m> occurrences of element. Default values are 0 and infinity so
        that "*(element)" allows any number, including zero; "1*element"
        requires at least one; and "1*2element" allows one or two.

Request parsing notes :

- Each header field consists of a name followed by a colon (":") and the field value.
- Field names are case-insensitive.
-  The field value MAY be preceded by any amount of LWS, though a single SP is preferred.
    (Header fields can be extended over multiple lines by preceding each extra line with
    at least one SP or HT)

        [0] . message-header = field-name ":" [ field-value ]
        [0] . field-name = token
        [0] . field-value = *( field-content | LWS )
        [0] . field-content = <the OCTETs making up the field-value
                and consisting of either *TEXT or combinations
                of token, separators, and quoted-string>
        [0] . token = 1*<any CHAR except CTLs or separators>
        [0] . separators = "(" | ")" | "<" | ">" | "@"
                | "," | ";" | ":" | "\" | <">
                | "/" | "[" | "]" | "?" | "="
                | "{" | "}" | SP | HT
        [0] .   comment = "(" *( ctext | quoted-pair | comment ) ")"
        [0] . ctext = <any TEXT excluding "(" and ")">
        [0] . quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
        [0] . qdtext = <any TEXT except <">>
        [0] . quoted-pair = "\" CHAR
        OCTET = <any 8-bit sequence of data>
        [*] . TEXT = <any OCTET except CTLs, but including LWS>
        [*]  . CHAR = <any US-ASCII character (octets 0 - 127)>
        [*]  . UPALPHA = <any US-ASCII uppercase letter "A".."Z">
        [*]  . LOALPHA = <any US-ASCII lowercase letter "a".."z">
        [*]  . ALPHA = UPALPHA | LOALPHA
        [*]  . DIGIT = <any US-ASCII digit "0".."9">
        [*]  . CTL = <any US-ASCII control character
        [*]  . (octets 0 - 31) and DEL (127)>
        [*]  . CR = <US-ASCII CR, carriage return (13)>
        [*]  . LF = <US-ASCII LF, linefeed (10)>
        [*]  . SP = <US-ASCII SP, space (32)>
        [*]  . HT = <US-ASCII HT, horizontal-tab (9)>
        [*]  . <"> = <US-ASCII double-quote mark (34)>
        [*]  . CRLF = CR LF
        [*]  . LWS = [CRLF] 1*( SP | HT )
        [*]  . HEX = "A" | "B" | "C" | "D" | "E" | "F"
                | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT
Terminology :

This specification uses a number of terms to refer to the roles
played by participants in, and objects of, the HTTP communication.

 - connection : 
        A transport layer virtual circuit established between two programs
        for the purpose of communication.
 - message :
    The basic unit of HTTP communication, consisting of a structured
    sequence of octets matching the syntax defined in section 4 and
    transmitted via the connection.
 - request :
    An HTTP request message, as defined in section 5.
 - response :
    An HTTP response message, as defined in section 6.
 - resource :
    A network data object or service that can be identified by a URI,
    as defined in section 3.2. Resources may be available in multiple
    representations (e.g. multiple languages, data formats, size, and
    resolutions) or vary in other ways.
 - entity :
    The information transferred as the payload of a request or
    response. An entity consists of metainformation in the form of
    entity-header fields and content in the form of an entity-body, as
    described in section 7.
 - representation :
    An entity included with a response that is subject to content
    negotiation, as described in section 12. There may exist multiple
    representations associated with a particular response status.
 - content negotiation :
    The mechanism for selecting the appropriate representation when
    servicing a request, as described in section 12. The
    representation of entities in any response can be negotiated
    (including error responses).
 - variant :
    A resource may have one, or more than one, representation(s)
    associated with it at any given instant. Each of these
    representations is termed a `varriant'. Use of the term `variant'
    does not necessarily imply that the resource is subject to content
 negotiation.
 - client :
    A program that establishes connections for the purpose of sending
    requests.
 - user agent :
    The client which initiates a request. These are often browsers,
    editors, spiders (web-traversing robots), or other end user tools.
 - server :
    An application program that accepts connections in order to
    service requests by sending back responses. Any given program may
    be capable of being both a client and a server; our use of these
    terms refers only to the role being performed by the program for a
    particular connection, rather than to the program's capabilities
    in general. Likewise, any server may act as an origin server,
    proxy, gateway, or tunnel, switching behavior based on the nature
    of each request.
 - origin server :
    The server on which a given resource resides or is to be created.
 - proxy :
    An intermediary program which acts as both a server and a client
    for the purpose of making requests on behalf of other clients.
    Requests are serviced internally or by passing them on, with
    possible translation, to other servers. A proxy MUST implement
    both the client and server requirements of this specification. A
    "transparent proxy" is a proxy that does not modify the request or
    response beyond what is required for proxy authentication and
    identification. A "non-transparent proxy" is a proxy that modifies
    the request or response in order to provide some added service to
    the user agent, such as group annotation services, media type
    transformation, protocol reduction, or anonymity filtering. Except
    where either transparent or non-transparent behavior is explicitly
    stated, the HTTP proxy requirements apply to both types of
    proxies.
 - gateway :
    A server which acts as an intermediary for some other server.
    Unlike a proxy, a gateway receives requests as if it were the
    origin server for the requested resource; the requesting client
    may not be aware that it is communicating with a gateway.
 - tunnel :
    An intermediary program which is acting as a blind relay between
    two connections. Once active, a tunnel is not considered a party
    to the HTTP communication, though the tunnel may have been
    initiated by an HTTP request. The tunnel ceases to exist when both
    ends of the relayed connections are closed.
 - cache :
    A program's local store of response messages and the subsystem
    that controls its message storage, retrieval, and deletion. A
    cache stores cacheable responses in order to reduce the response
    time and network bandwidth consumption on future, equivalent
    requests. Any client or server may include a cache, though a cache
    cannot be used by a server that is acting as a tunnel.
 - cacheable :
    A response is cacheable if a cache is allowed to store a copy of
    the response message for use in answering subsequent requests. The
    rules for determining the cacheability of HTTP responses are
    defined in section 13. Even if a resource is cacheable, there may
    be additional constraints on whether a cache can use the cached
    copy for a particular request.
- first-hand :
    A response is first-hand if it comes directly and without
    unnecessary delay from the origin server, perhaps via one or more
    proxies. A response is also first-hand if its validity has just
    been checked directly with the origin server.
 - explicit expiration time :
    The time at which the origin server intends that an entity should
    no longer be returned by a cache without further validation.
 - heuristic expiration time :
    An expiration time assigned by a cache when no explicit expiration
    time is available.
 - age :
    The age of a response is the time since it was sent by, or
    successfully validated with, the origin server.
 - freshness lifetime :
    The length of time between the generation of a response and its
    expiration time.
 - fresh :
    A response is fresh if its age has not yet exceeded its freshness
    lifetime.
 - stale :
    A response is stale if its age has passed its freshness lifetime.
 - semantically transparent :
    A cache behaves in a "semantically transparent" manner, with
    respect to a particular response, when its use affects neither the
    requesting client nor the origin server, except to improve
    performance. When a cache is semantically transparent, the client
    receives exactly the same response (except for hop-by-hop headers)
    that it would have received had its request been handled directly
    by the origin server.
  - validator :
    A protocol element (e.g., an entity tag or a Last-Modified time)
    that is used to find out whether a cache entry is an equivalent
    copy of an entity.
  - upstream/downstream :
    Upstream and downstream describe the flow of a message: all
    messages flow from upstream to downstream.
 - inbound/outbound :
    Inbound and outbound refer to the request and response paths for
    messages: "inbound" means "traveling toward the origin server",
    and "outbound" means "traveling toward the user agent"

Request parsing plane :
 - first let replace and LWS with one SP . [this can be judged if it wrong!]
 - Not ALL the request method allow the entity_body to be exist.
  [The presence of a message-body in a request is signaled by the
    inclusion of a Content-Length or Transfer-Encoding header field in
    the request's message-headers. A message-body MUST NOT be included in
    a request if the specification of the request method (section 5.1.1)
    does not allow sending an entity-body in requests. A server SHOULD
    read and forward a message-body on any request; if the request method
    does not include defined semantics for an entity-body, then the
    message-body SHOULD be ignored when handling the request.](rfc 2616 page 33)

Request parsing CONIDIRATION :
-   Multiple message-header fields with the same field-name MAY be
    present in a message if and only if the entire field-value for that
    header field is defined as a comma-separated list [i.e., #(values)]. [solution is in not [-0-][-2-]]

Advices from the RFC in Request parsing : 
    [-0-] in headers level: 
        [-0-][-0-] The field-content does not include any leading or trailing LWS:
        linear white space occurring before the first non-whitespace
        character of the field-value or after the last non-whitespace
        character of the field-value. Such leading or trailing LWS MAY be
        removed without changing the semantics of the field value. Any LWS
        that occurs between field-content MAY be replaced with a single SP
        before interpreting the field value or forwarding the message
        downstream.

        [-0-][-1-] The order in which header fields with differing field names are
        received is not significant. However, it is "good practice" to send
        general-header fields first, followed by request-header or response-
        header fields, and ending with the entity-header fields.

        [-0-][-2-] Multiple message-header fields with the same field-name MAY be
        present in a message if and only if the entire field-value for that
        header field is defined as a comma-separated list [i.e., #(values)].
        It MUST be possible to combine the multiple header fields into one
        "field-name: field-value" pair, without changing the semantics of the
        message, by appending each subsequent field-value to the first, each
        separated by a comma. The order in which header fields with the same
        field-name are received is therefore significant to the
        interpretation of the combined field value, and thus a proxy MUST NOT
        change the order of these field values when a message is forwarded.

Response message :

- For response messages, whether or not a message-body is included with
    a message is dependent on both the request method and the response
    status code (section 6.1.1). All responses to the HEAD request method
    MUST NOT include a message-body, even though the presence of entity-
    header fields might lead one to believe they do. All 1xx
    (informational), 204 (no content), and 304 (not modified) responses
    MUST NOT include a message-body. All other responses do include a
    message-body, although it MAY be of zero length.